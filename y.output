Terminals unused in grammar

    BREAK
    FUNCTION
    NIL
    VAR
    SEMICOLON
    STRING_CONSTANT
    INVALID_TOKEN
    END_OF_FILE
    UNARY_MINUS


Grammar

    0 $accept: prog $end

    1 prog: stm

    2 stm: assignStm
    3    | conditionStm
    4    | whileStm
    5    | forStm
    6    | letStm
    7    | algorithmExp

    8 assignStm: lvalue ASSIGN algorithmExp

    9 conditionStm: IF relationExp THEN stm
   10             | IF relationExp THEN stm ELSE stm

   11 whileStm: WHILE relationExp DO stm

   12 forStm: FOR ID ASSIGN algorithmExp TO algorithmExp DO stm

   13 letStm: LET declaration_list IN stm END

   14 lvalue: ID
   15       | lvalue DOT ID
   16       | lvalue LBRACKET algorithmExp RBRACKET

   17 relationExp: relationExpItem
   18            | relationExp AND relationExpItem
   19            | relationExp OR relationExpItem

   20 relationExpItem: algorithmExp relationOp algorithmExp
   21                | algorithmExp

   22 algorithmExp: item
   23             | algorithmExp PLUS item
   24             | algorithmExp MINUS item

   25 item: frator
   26     | item MULTIPLY frator
   27     | item DIVIDE frator

   28 frator: ID
   29       | INTEGER_CONSTANT
   30       | LPAREN algorithmExp RPAREN
   31       | MINUS frator

   32 relationOp: EQUAL
   33           | NOT_EQUAL
   34           | GREATER_THAN
   35           | LESS_THAN
   36           | GREATER_THAN_OR_EQUAL
   37           | LESS_THAN_OR_EQUAL

   38 declaration_list: declaration
   39                 | declaration_list declaration

   40 declaration: type_declaration

   41 type_declaration: TYPE ID EQUAL type

   42 type: ID
   43     | LBRACE type_fields_opt RBRACE
   44     | ARRAY OF ID

   45 type_fields_opt: type_fields
   46                | ε

   47 type_fields: type_field
   48            | type_fields COMMA type_field

   49 type_field: ID COLON ID


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    ARRAY (258) 44
    BREAK (259)
    DO (260) 11 12
    ELSE (261) 10
    END (262) 13
    FOR (263) 12
    FUNCTION (264)
    IF (265) 9 10
    IN (266) 13
    LET (267) 13
    NIL (268)
    OF (269) 44
    THEN (270) 9 10
    TO (271) 12
    TYPE (272) 41
    VAR (273)
    WHILE (274) 11
    COMMA (275) 48
    COLON (276) 49
    SEMICOLON (277)
    LPAREN (278) 30
    RPAREN (279) 30
    LBRACKET (280) 16
    RBRACKET (281) 16
    LBRACE (282) 43
    RBRACE (283) 43
    DOT (284) 15
    PLUS (285) 23
    MINUS (286) 24 31
    MULTIPLY (287) 26
    DIVIDE (288) 27
    EQUAL (289) 32 41
    NOT_EQUAL (290) 33
    LESS_THAN (291) 35
    LESS_THAN_OR_EQUAL (292) 37
    GREATER_THAN (293) 34
    GREATER_THAN_OR_EQUAL (294) 36
    AND (295) 18
    OR (296) 19
    ASSIGN (297) 8 12
    STRING_CONSTANT (298)
    INVALID_TOKEN (299)
    END_OF_FILE (300)
    UNARY_MINUS (301)
    ID <id> (302) 12 14 15 28 41 42 44 49
    INTEGER_CONSTANT <i> (303) 29
    LOWER_THAN_ELSE (304)


Nonterminals, with rules where they appear

    $accept (50)
        on left: 0
    prog (51)
        on left: 1
        on right: 0
    stm (52)
        on left: 2 3 4 5 6 7
        on right: 1 9 10 11 12 13
    assignStm (53)
        on left: 8
        on right: 2
    conditionStm (54)
        on left: 9 10
        on right: 3
    whileStm (55)
        on left: 11
        on right: 4
    forStm (56)
        on left: 12
        on right: 5
    letStm (57)
        on left: 13
        on right: 6
    lvalue (58)
        on left: 14 15 16
        on right: 8 15 16
    relationExp (59)
        on left: 17 18 19
        on right: 9 10 11 18 19
    relationExpItem (60)
        on left: 20 21
        on right: 17 18 19
    algorithmExp (61)
        on left: 22 23 24
        on right: 7 8 12 16 20 21 23 24 30
    item (62)
        on left: 25 26 27
        on right: 22 23 24 26 27
    frator (63)
        on left: 28 29 30 31
        on right: 25 26 27 31
    relationOp (64)
        on left: 32 33 34 35 36 37
        on right: 20
    declaration_list (65)
        on left: 38 39
        on right: 13 39
    declaration (66)
        on left: 40
        on right: 38 39
    type_declaration (67)
        on left: 41
        on right: 40
    type (68)
        on left: 42 43 44
        on right: 41
    type_fields_opt (69)
        on left: 45 46
        on right: 43
    type_fields (70)
        on left: 47 48
        on right: 45 48
    type_field (71)
        on left: 49
        on right: 47 48


State 0

    0 $accept: • prog $end

    FOR               shift, and go to state 1
    IF                shift, and go to state 2
    LET               shift, and go to state 3
    WHILE             shift, and go to state 4
    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 7
    INTEGER_CONSTANT  shift, and go to state 8

    prog          go to state 9
    stm           go to state 10
    assignStm     go to state 11
    conditionStm  go to state 12
    whileStm      go to state 13
    forStm        go to state 14
    letStm        go to state 15
    lvalue        go to state 16
    algorithmExp  go to state 17
    item          go to state 18
    frator        go to state 19


State 1

   12 forStm: FOR • ID ASSIGN algorithmExp TO algorithmExp DO stm

    ID  shift, and go to state 20


State 2

    9 conditionStm: IF • relationExp THEN stm
   10             | IF • relationExp THEN stm ELSE stm

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    relationExp      go to state 22
    relationExpItem  go to state 23
    algorithmExp     go to state 24
    item             go to state 18
    frator           go to state 19


State 3

   13 letStm: LET • declaration_list IN stm END

    TYPE  shift, and go to state 25

    declaration_list  go to state 26
    declaration       go to state 27
    type_declaration  go to state 28


State 4

   11 whileStm: WHILE • relationExp DO stm

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    relationExp      go to state 29
    relationExpItem  go to state 23
    algorithmExp     go to state 24
    item             go to state 18
    frator           go to state 19


State 5

   30 frator: LPAREN • algorithmExp RPAREN

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    algorithmExp  go to state 30
    item          go to state 18
    frator        go to state 19


State 6

   31 frator: MINUS • frator

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    frator  go to state 31


State 7

   14 lvalue: ID •
   28 frator: ID •

    LBRACKET  reduce using rule 14 (lvalue)
    DOT       reduce using rule 14 (lvalue)
    ASSIGN    reduce using rule 14 (lvalue)
    $default  reduce using rule 28 (frator)


State 8

   29 frator: INTEGER_CONSTANT •

    $default  reduce using rule 29 (frator)


State 9

    0 $accept: prog • $end

    $end  shift, and go to state 32


State 10

    1 prog: stm •

    $default  reduce using rule 1 (prog)


State 11

    2 stm: assignStm •

    $default  reduce using rule 2 (stm)


State 12

    3 stm: conditionStm •

    $default  reduce using rule 3 (stm)


State 13

    4 stm: whileStm •

    $default  reduce using rule 4 (stm)


State 14

    5 stm: forStm •

    $default  reduce using rule 5 (stm)


State 15

    6 stm: letStm •

    $default  reduce using rule 6 (stm)


State 16

    8 assignStm: lvalue • ASSIGN algorithmExp
   15 lvalue: lvalue • DOT ID
   16       | lvalue • LBRACKET algorithmExp RBRACKET

    LBRACKET  shift, and go to state 33
    DOT       shift, and go to state 34
    ASSIGN    shift, and go to state 35


State 17

    7 stm: algorithmExp •
   23 algorithmExp: algorithmExp • PLUS item
   24             | algorithmExp • MINUS item

    PLUS   shift, and go to state 36
    MINUS  shift, and go to state 37

    $default  reduce using rule 7 (stm)


State 18

   22 algorithmExp: item •
   26 item: item • MULTIPLY frator
   27     | item • DIVIDE frator

    MULTIPLY  shift, and go to state 38
    DIVIDE    shift, and go to state 39

    $default  reduce using rule 22 (algorithmExp)


State 19

   25 item: frator •

    $default  reduce using rule 25 (item)


State 20

   12 forStm: FOR ID • ASSIGN algorithmExp TO algorithmExp DO stm

    ASSIGN  shift, and go to state 40


State 21

   28 frator: ID •

    $default  reduce using rule 28 (frator)


State 22

    9 conditionStm: IF relationExp • THEN stm
   10             | IF relationExp • THEN stm ELSE stm
   18 relationExp: relationExp • AND relationExpItem
   19            | relationExp • OR relationExpItem

    THEN  shift, and go to state 41
    AND   shift, and go to state 42
    OR    shift, and go to state 43


State 23

   17 relationExp: relationExpItem •

    $default  reduce using rule 17 (relationExp)


State 24

   20 relationExpItem: algorithmExp • relationOp algorithmExp
   21                | algorithmExp •
   23 algorithmExp: algorithmExp • PLUS item
   24             | algorithmExp • MINUS item

    PLUS                   shift, and go to state 36
    MINUS                  shift, and go to state 37
    EQUAL                  shift, and go to state 44
    NOT_EQUAL              shift, and go to state 45
    LESS_THAN              shift, and go to state 46
    LESS_THAN_OR_EQUAL     shift, and go to state 47
    GREATER_THAN           shift, and go to state 48
    GREATER_THAN_OR_EQUAL  shift, and go to state 49

    $default  reduce using rule 21 (relationExpItem)

    relationOp  go to state 50


State 25

   41 type_declaration: TYPE • ID EQUAL type

    ID  shift, and go to state 51


State 26

   13 letStm: LET declaration_list • IN stm END
   39 declaration_list: declaration_list • declaration

    IN    shift, and go to state 52
    TYPE  shift, and go to state 25

    declaration       go to state 53
    type_declaration  go to state 28


State 27

   38 declaration_list: declaration •

    $default  reduce using rule 38 (declaration_list)


State 28

   40 declaration: type_declaration •

    $default  reduce using rule 40 (declaration)


State 29

   11 whileStm: WHILE relationExp • DO stm
   18 relationExp: relationExp • AND relationExpItem
   19            | relationExp • OR relationExpItem

    DO   shift, and go to state 54
    AND  shift, and go to state 42
    OR   shift, and go to state 43


State 30

   23 algorithmExp: algorithmExp • PLUS item
   24             | algorithmExp • MINUS item
   30 frator: LPAREN algorithmExp • RPAREN

    RPAREN  shift, and go to state 55
    PLUS    shift, and go to state 36
    MINUS   shift, and go to state 37


State 31

   31 frator: MINUS frator •

    $default  reduce using rule 31 (frator)


State 32

    0 $accept: prog $end •

    $default  accept


State 33

   16 lvalue: lvalue LBRACKET • algorithmExp RBRACKET

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    algorithmExp  go to state 56
    item          go to state 18
    frator        go to state 19


State 34

   15 lvalue: lvalue DOT • ID

    ID  shift, and go to state 57


State 35

    8 assignStm: lvalue ASSIGN • algorithmExp

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    algorithmExp  go to state 58
    item          go to state 18
    frator        go to state 19


State 36

   23 algorithmExp: algorithmExp PLUS • item

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    item    go to state 59
    frator  go to state 19


State 37

   24 algorithmExp: algorithmExp MINUS • item

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    item    go to state 60
    frator  go to state 19


State 38

   26 item: item MULTIPLY • frator

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    frator  go to state 61


State 39

   27 item: item DIVIDE • frator

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    frator  go to state 62


State 40

   12 forStm: FOR ID ASSIGN • algorithmExp TO algorithmExp DO stm

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    algorithmExp  go to state 63
    item          go to state 18
    frator        go to state 19


State 41

    9 conditionStm: IF relationExp THEN • stm
   10             | IF relationExp THEN • stm ELSE stm

    FOR               shift, and go to state 1
    IF                shift, and go to state 2
    LET               shift, and go to state 3
    WHILE             shift, and go to state 4
    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 7
    INTEGER_CONSTANT  shift, and go to state 8

    stm           go to state 64
    assignStm     go to state 11
    conditionStm  go to state 12
    whileStm      go to state 13
    forStm        go to state 14
    letStm        go to state 15
    lvalue        go to state 16
    algorithmExp  go to state 17
    item          go to state 18
    frator        go to state 19


State 42

   18 relationExp: relationExp AND • relationExpItem

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    relationExpItem  go to state 65
    algorithmExp     go to state 24
    item             go to state 18
    frator           go to state 19


State 43

   19 relationExp: relationExp OR • relationExpItem

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    relationExpItem  go to state 66
    algorithmExp     go to state 24
    item             go to state 18
    frator           go to state 19


State 44

   32 relationOp: EQUAL •

    $default  reduce using rule 32 (relationOp)


State 45

   33 relationOp: NOT_EQUAL •

    $default  reduce using rule 33 (relationOp)


State 46

   35 relationOp: LESS_THAN •

    $default  reduce using rule 35 (relationOp)


State 47

   37 relationOp: LESS_THAN_OR_EQUAL •

    $default  reduce using rule 37 (relationOp)


State 48

   34 relationOp: GREATER_THAN •

    $default  reduce using rule 34 (relationOp)


State 49

   36 relationOp: GREATER_THAN_OR_EQUAL •

    $default  reduce using rule 36 (relationOp)


State 50

   20 relationExpItem: algorithmExp relationOp • algorithmExp

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    algorithmExp  go to state 67
    item          go to state 18
    frator        go to state 19


State 51

   41 type_declaration: TYPE ID • EQUAL type

    EQUAL  shift, and go to state 68


State 52

   13 letStm: LET declaration_list IN • stm END

    FOR               shift, and go to state 1
    IF                shift, and go to state 2
    LET               shift, and go to state 3
    WHILE             shift, and go to state 4
    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 7
    INTEGER_CONSTANT  shift, and go to state 8

    stm           go to state 69
    assignStm     go to state 11
    conditionStm  go to state 12
    whileStm      go to state 13
    forStm        go to state 14
    letStm        go to state 15
    lvalue        go to state 16
    algorithmExp  go to state 17
    item          go to state 18
    frator        go to state 19


State 53

   39 declaration_list: declaration_list declaration •

    $default  reduce using rule 39 (declaration_list)


State 54

   11 whileStm: WHILE relationExp DO • stm

    FOR               shift, and go to state 1
    IF                shift, and go to state 2
    LET               shift, and go to state 3
    WHILE             shift, and go to state 4
    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 7
    INTEGER_CONSTANT  shift, and go to state 8

    stm           go to state 70
    assignStm     go to state 11
    conditionStm  go to state 12
    whileStm      go to state 13
    forStm        go to state 14
    letStm        go to state 15
    lvalue        go to state 16
    algorithmExp  go to state 17
    item          go to state 18
    frator        go to state 19


State 55

   30 frator: LPAREN algorithmExp RPAREN •

    $default  reduce using rule 30 (frator)


State 56

   16 lvalue: lvalue LBRACKET algorithmExp • RBRACKET
   23 algorithmExp: algorithmExp • PLUS item
   24             | algorithmExp • MINUS item

    RBRACKET  shift, and go to state 71
    PLUS      shift, and go to state 36
    MINUS     shift, and go to state 37


State 57

   15 lvalue: lvalue DOT ID •

    $default  reduce using rule 15 (lvalue)


State 58

    8 assignStm: lvalue ASSIGN algorithmExp •
   23 algorithmExp: algorithmExp • PLUS item
   24             | algorithmExp • MINUS item

    PLUS   shift, and go to state 36
    MINUS  shift, and go to state 37

    $default  reduce using rule 8 (assignStm)


State 59

   23 algorithmExp: algorithmExp PLUS item •
   26 item: item • MULTIPLY frator
   27     | item • DIVIDE frator

    MULTIPLY  shift, and go to state 38
    DIVIDE    shift, and go to state 39

    $default  reduce using rule 23 (algorithmExp)


State 60

   24 algorithmExp: algorithmExp MINUS item •
   26 item: item • MULTIPLY frator
   27     | item • DIVIDE frator

    MULTIPLY  shift, and go to state 38
    DIVIDE    shift, and go to state 39

    $default  reduce using rule 24 (algorithmExp)


State 61

   26 item: item MULTIPLY frator •

    $default  reduce using rule 26 (item)


State 62

   27 item: item DIVIDE frator •

    $default  reduce using rule 27 (item)


State 63

   12 forStm: FOR ID ASSIGN algorithmExp • TO algorithmExp DO stm
   23 algorithmExp: algorithmExp • PLUS item
   24             | algorithmExp • MINUS item

    TO     shift, and go to state 72
    PLUS   shift, and go to state 36
    MINUS  shift, and go to state 37


State 64

    9 conditionStm: IF relationExp THEN stm •
   10             | IF relationExp THEN stm • ELSE stm

    ELSE  shift, and go to state 73

    $default  reduce using rule 9 (conditionStm)


State 65

   18 relationExp: relationExp AND relationExpItem •

    $default  reduce using rule 18 (relationExp)


State 66

   19 relationExp: relationExp OR relationExpItem •

    $default  reduce using rule 19 (relationExp)


State 67

   20 relationExpItem: algorithmExp relationOp algorithmExp •
   23 algorithmExp: algorithmExp • PLUS item
   24             | algorithmExp • MINUS item

    PLUS   shift, and go to state 36
    MINUS  shift, and go to state 37

    $default  reduce using rule 20 (relationExpItem)


State 68

   41 type_declaration: TYPE ID EQUAL • type

    ARRAY   shift, and go to state 74
    LBRACE  shift, and go to state 75
    ID      shift, and go to state 76

    type  go to state 77


State 69

   13 letStm: LET declaration_list IN stm • END

    END  shift, and go to state 78


State 70

   11 whileStm: WHILE relationExp DO stm •

    $default  reduce using rule 11 (whileStm)


State 71

   16 lvalue: lvalue LBRACKET algorithmExp RBRACKET •

    $default  reduce using rule 16 (lvalue)


State 72

   12 forStm: FOR ID ASSIGN algorithmExp TO • algorithmExp DO stm

    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 21
    INTEGER_CONSTANT  shift, and go to state 8

    algorithmExp  go to state 79
    item          go to state 18
    frator        go to state 19


State 73

   10 conditionStm: IF relationExp THEN stm ELSE • stm

    FOR               shift, and go to state 1
    IF                shift, and go to state 2
    LET               shift, and go to state 3
    WHILE             shift, and go to state 4
    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 7
    INTEGER_CONSTANT  shift, and go to state 8

    stm           go to state 80
    assignStm     go to state 11
    conditionStm  go to state 12
    whileStm      go to state 13
    forStm        go to state 14
    letStm        go to state 15
    lvalue        go to state 16
    algorithmExp  go to state 17
    item          go to state 18
    frator        go to state 19


State 74

   44 type: ARRAY • OF ID

    OF  shift, and go to state 81


State 75

   43 type: LBRACE • type_fields_opt RBRACE

    ID  shift, and go to state 82

    $default  reduce using rule 46 (type_fields_opt)

    type_fields_opt  go to state 83
    type_fields      go to state 84
    type_field       go to state 85


State 76

   42 type: ID •

    $default  reduce using rule 42 (type)


State 77

   41 type_declaration: TYPE ID EQUAL type •

    $default  reduce using rule 41 (type_declaration)


State 78

   13 letStm: LET declaration_list IN stm END •

    $default  reduce using rule 13 (letStm)


State 79

   12 forStm: FOR ID ASSIGN algorithmExp TO algorithmExp • DO stm
   23 algorithmExp: algorithmExp • PLUS item
   24             | algorithmExp • MINUS item

    DO     shift, and go to state 86
    PLUS   shift, and go to state 36
    MINUS  shift, and go to state 37


State 80

   10 conditionStm: IF relationExp THEN stm ELSE stm •

    $default  reduce using rule 10 (conditionStm)


State 81

   44 type: ARRAY OF • ID

    ID  shift, and go to state 87


State 82

   49 type_field: ID • COLON ID

    COLON  shift, and go to state 88


State 83

   43 type: LBRACE type_fields_opt • RBRACE

    RBRACE  shift, and go to state 89


State 84

   45 type_fields_opt: type_fields •
   48 type_fields: type_fields • COMMA type_field

    COMMA  shift, and go to state 90

    $default  reduce using rule 45 (type_fields_opt)


State 85

   47 type_fields: type_field •

    $default  reduce using rule 47 (type_fields)


State 86

   12 forStm: FOR ID ASSIGN algorithmExp TO algorithmExp DO • stm

    FOR               shift, and go to state 1
    IF                shift, and go to state 2
    LET               shift, and go to state 3
    WHILE             shift, and go to state 4
    LPAREN            shift, and go to state 5
    MINUS             shift, and go to state 6
    ID                shift, and go to state 7
    INTEGER_CONSTANT  shift, and go to state 8

    stm           go to state 91
    assignStm     go to state 11
    conditionStm  go to state 12
    whileStm      go to state 13
    forStm        go to state 14
    letStm        go to state 15
    lvalue        go to state 16
    algorithmExp  go to state 17
    item          go to state 18
    frator        go to state 19


State 87

   44 type: ARRAY OF ID •

    $default  reduce using rule 44 (type)


State 88

   49 type_field: ID COLON • ID

    ID  shift, and go to state 92


State 89

   43 type: LBRACE type_fields_opt RBRACE •

    $default  reduce using rule 43 (type)


State 90

   48 type_fields: type_fields COMMA • type_field

    ID  shift, and go to state 82

    type_field  go to state 93


State 91

   12 forStm: FOR ID ASSIGN algorithmExp TO algorithmExp DO stm •

    $default  reduce using rule 12 (forStm)


State 92

   49 type_field: ID COLON ID •

    $default  reduce using rule 49 (type_field)


State 93

   48 type_fields: type_fields COMMA type_field •

    $default  reduce using rule 48 (type_fields)
